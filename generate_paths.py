from random import randint
def normal_range(x1, x2):
    #x = int(normal((x1 + x2)/2, sqrt(x2-x1)))
    x = randint(x1, x2)
    #x = int(np.random.triangular(x1-1, (x1 + x2)/2. , x2+1))
    return max(x1, min(x2, x))

def rotate_path(path, x_len, y_len, dx, dy):
    return [((x_len-x)*dx + x*(1-dx), (y_len-y)*dy + y*(1-dy))
            for x, y in path]

def translate_path(path, dx, dy):
    return [(x+dx, y+dy) for x, y in path]

def noise_path(path, noise_fn):
    '''For every point on PATH, NOISE_FN generates a random noise vector which
    is then added to that point'''
    new_path = []
    for x, y in path:
        dx, dy = noise_fn()
        new_path.append((x + dx, y + dy))
    return new_path

def gen_random_path(x1, y1, x2, y2):
    ''' Random path in a rectangle starting at (x1, y1) and ending at (x2, y2).
    Generated by picking a random point based on some distribution in the range
    [x1, x2] and [y1, y2], and recursing on the subrectangles defined by that
    point.
    '''
    if x1  == x2:
        return [(x1, y) for y in range(y1, y2)]
    elif y1 == y2:
        return [(x, y1) for x in range(x1, x2)]
    else:
        x, y = normal_range(x1, x2), normal_range(y1, y2)
        return gen_random_path(x1, y1, x, y) + gen_random_path(x, y, x2, y2)

def random_path(min_len, max_len, max_coord):
    ''' Generate a random path of length between MIN_LEN and MAX_LEN, within a
    square of length MAX_COORD
    '''
    x_len, y_len = randint(min_len, max_len), randint(min_len, max_len)
    x = randint(0, max_coord - x_len)
    y = randint(0, max_coord - y_len)
    path = gen_random_path(0, 0, x_len, y_len)
    path = rotate_path(path, x_len, y_len, randint(0, 1), randint(0, 1))
    return translate_path(path, x, y)
